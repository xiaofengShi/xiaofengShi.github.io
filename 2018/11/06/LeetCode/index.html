<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/panda_32px.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/panda_16px.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://xiaofengshi.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="leetcode漫漫求索路……🛣，进行日常算法训练，就当强身健体了😢，燥起来吧......">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode算法训练">
<meta property="og:url" content="http://xiaofengshi.com/2018/11/06/LeetCode/index.html">
<meta property="og:site_name" content="做一个有用的人">
<meta property="og:description" content="leetcode漫漫求索路……🛣，进行日常算法训练，就当强身健体了😢，燥起来吧......">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xiaofengshi.com/2018/11/06/LeetCode/logo.jpeg">
<meta property="og:image" content="http://xiaofengshi.com/2018/11/06/LeetCode/add_2.png">
<meta property="og:image" content="http://xiaofengshi.com/2018/11/06/LeetCode/z-trans.png">
<meta property="article:published_time" content="2018-11-06T03:40:59.000Z">
<meta property="article:modified_time" content="2020-10-04T12:57:55.000Z">
<meta property="article:author" content="ShiXiaofeng">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xiaofengshi.com/2018/11/06/LeetCode/logo.jpeg">

<link rel="canonical" href="http://xiaofengshi.com/2018/11/06/LeetCode/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>LeetCode算法训练 | 做一个有用的人</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">做一个有用的人</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">LLM And Search</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-fw fa-calendar"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook/" rel="section"><i class="fa fa-fw fa-commenting"></i>guestbook</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/xiaofengShi" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaofengshi.com/2018/11/06/LeetCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ShiXiaofeng">
      <meta itemprop="description" content="LLM,搜索,数据挖掘,深度学习相关技术记录分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="做一个有用的人">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          LeetCode算法训练
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-06 11:40:59" itemprop="dateCreated datePublished" datetime="2018-11-06T11:40:59+08:00">2018-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-04 20:57:55" itemprop="dateModified" datetime="2020-10-04T20:57:55+08:00">2020-10-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode</span>
                  </a>
                </span>
            </span>

          
            <span id="/2018/11/06/LeetCode/" class="post-meta-item leancloud_visitors" data-flag-title="LeetCode算法训练" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/11/06/LeetCode/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/11/06/LeetCode/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <img src="/2018/11/06/LeetCode/logo.jpeg" class="">

<hr>leetcode漫漫求索路……🛣，进行日常算法训练，就当强身健体了😢，燥起来吧......
<span id="more"></span>
##  从排序数组中删除重复项

<ul>
<li><p>原题链接<a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/21/">https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/21/</a></p>
</li>
<li><p>题解：给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p>这道题目很简单，关键词有三个：<strong>排序数组，原地删除，返回新数组长度</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        - 排序数组</span></span><br><span class="line"><span class="string">        - 原地删除</span></span><br><span class="line"><span class="string">        - 返回新数组长度</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length=<span class="built_in">len</span>(nums)</span><br><span class="line">        idx=count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> count&lt;length:</span><br><span class="line">            <span class="keyword">if</span> nums[count]&gt;nums[idx]:</span><br><span class="line">                idx+=<span class="number">1</span></span><br><span class="line">                nums[idx]=nums[count]</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> idx+<span class="number">1</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><ul>
<li><p>原题链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>
</li>
<li><p>题意：给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
</li>
</ul>
<p><strong>注意</strong>：你不能在买入股票前卖出股票。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分析</p>
<p>题目中要求最多允许完成一次交易，并且得到最大的收益，这是一个很明显的动态规划问题，我们可以将问题进行拆解，会发现在整个输入序列中，相邻元素之间如果后者大于前者则存在收益；否则没有收益，并且我们要的是最大的收益，那么就需要比较当前这一步的收益和之前得到的所以之间取大值，即<br>$$<br>profit&#x3D;max(profit,sale-buy)<br>$$<br>$profit$为获得的收益，$sale$为卖出交个，$buy$为买入价格，由于限制了单次交易，那么买入的价格应该选择最低的价格，而卖出应该选择比上次的收益更大的价格，代码如下</p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        benefit=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 给定一个买入的初始值</span></span><br><span class="line">        buy=prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> sale <span class="keyword">in</span> prices[<span class="number">1</span>:]:</span><br><span class="line">            <span class="comment"># 找到买入的价格</span></span><br><span class="line">            buy=<span class="built_in">min</span>(buy,sale)</span><br><span class="line">            <span class="comment"># 收益为上次的计算的收益和当前的收益中最大的</span></span><br><span class="line">            benefit=<span class="built_in">max</span>(benefit,sale-buy)</span><br><span class="line">        <span class="keyword">return</span> benefit</span><br></pre></td></tr></table></figure>

<hr>

<h2 id="买卖股票最佳时机-II"><a href="#买卖股票最佳时机-II" class="headerlink" title="买卖股票最佳时机 II"></a>买卖股票最佳时机 II</h2><ul>
<li><p>原题链接：<a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/22/">https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/22/</a></p>
</li>
<li><p>题意：给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
</li>
</ul>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<ul>
<li>分析：根据题意，求解的是<strong>累计总收益</strong>，实际上在leetcode中有一个类似的求解收益的问题是，求解的是单次投资的最大收益，那个使用动态规划的思路求解,也就是上面那道题，说到本题目，有两种思路。<ul>
<li>方法一：直接根据题意和例子进行分析，遍历价格列表，假设初始价格为a，也就是prices[0]&#x3D;a，当前价格如果大于初始价格并且大于当前的下一个价格，则认为是卖出点，获得收益；如果当前价格小于初始价格，那么对初始价格进行更新，更新为当前的价格</li>
<li>方法二：利用加法交换律，D-A&#x3D;(D-C)+(C-B)+(B-A)，这样思考的话就不用具体考虑当前价格和初始价格的关系，只管比较当前价格和前一个价格之间的关系，如果当前价格大于之前一个的价格，则获得收益，使用迭代的方法，遍历到价格列表最后就可获得总收益</li>
</ul>
</li>
<li>代码：将两种方法的写在了一个代码段之中，并使用注释隔开</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        减法交换律</span></span><br><span class="line"><span class="string">        c-a=(c-b)+(b-a)</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        profit=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 第一种低效方法，直接题意入手</span></span><br><span class="line">        <span class="comment"># 给定另个指针count，idx，</span></span><br><span class="line">        <span class="comment"># 如果idx大于count并且idx大于idx+1，产生利润</span></span><br><span class="line">        <span class="comment"># 如果idx+1，count，对count向前移动</span></span><br><span class="line">        <span class="comment"># 所说的idx和count为对应的prices相应位置的值</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        count=idx=0</span></span><br><span class="line"><span class="string">        length=len(prices)</span></span><br><span class="line"><span class="string">        if not prices:</span></span><br><span class="line"><span class="string">            return profit</span></span><br><span class="line"><span class="string">        while idx&lt;length-1:</span></span><br><span class="line"><span class="string">            if prices[idx]&gt;prices[count] and prices[idx]&gt;prices[idx+1]:</span></span><br><span class="line"><span class="string">                profit+=prices[idx]-prices[count]</span></span><br><span class="line"><span class="string">                count=idx+1</span></span><br><span class="line"><span class="string">            elif prices[idx+1]&lt;prices[count]:</span></span><br><span class="line"><span class="string">                count=idx+1</span></span><br><span class="line"><span class="string">            idx+=1</span></span><br><span class="line"><span class="string">        profit+=prices[idx]-prices[count]</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 第二种高效方法,利用加法交换律</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i-<span class="number">1</span>]&lt;prices[i]:</span><br><span class="line">                profit+=prices[i]-prices[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>

<h2 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a>最佳买卖股票时机含冷冻期</h2><ul>
<li><p>原题链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/comments/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/comments/</a></p>
</li>
<li><p>题解：</p>
<p>给定一个整数数组，其中第 <em>i</em> 个元素代表了第 <em>i</em> 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li><strong>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</strong></li>
</ul>
</li>
<li><p>示例</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分析</p>
<p>整个购买过程包含买入，卖出和冷冻，可以创建三个数组分别表示在第i天时候对应的是买入，卖出和冷冻状态下的收益状况buy,sale,cold</p>
<ul>
<li>第i天为买入状态下的收益情况buy[i]<ul>
<li>前一天不持有股票，也就是为冷冻状态，那么今天买入得到的收益为cold[i-1]-pirces[i]</li>
<li>前一天持有股票，那么肯定前一天为买入状态，那么今天买入得到的收益为buy[i-1]</li>
<li>取两种情况下的最大收益情况为今天买入的收益状况</li>
</ul>
</li>
<li>第i天为卖出状态下的收益情况sale[i]<ul>
<li>前一天不持有股票，也就是前一天股票就是卖出状态，那么今天的卖出收益为sale[i-1]</li>
<li>前一天持有股票，那么前一天为买入状态，由此，今天的卖出收益为buy[i-1]+prices[i]</li>
</ul>
</li>
<li>第i天为冷冻状态下的收益情况cold[i]<ul>
<li>前一天刚卖出，今天冷冻的收益为sale[i-1]</li>
<li>前一天就已经冷冻，今天的冷冻收益为cold[i-1]</li>
</ul>
</li>
</ul>
<p>最终得到的最大收益，最后一天的状况应该是卖出</p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        length=<span class="built_in">len</span>(prices)</span><br><span class="line">        sale,buy,cold=[<span class="number">0</span>]*length,[<span class="number">0</span>]*length,[<span class="number">0</span>]*length</span><br><span class="line">        buy[<span class="number">0</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length):</span><br><span class="line">            buy[i]=<span class="built_in">max</span>(cold[i-<span class="number">1</span>]-prices[i],buy[i-<span class="number">1</span>]) </span><br><span class="line">            sale[i]=<span class="built_in">max</span>(buy[i-<span class="number">1</span>]+prices[i],sale[i-<span class="number">1</span>]) </span><br><span class="line">            cold[i]=<span class="built_in">max</span>(sale[i-<span class="number">1</span>],cold[i-<span class="number">1</span>]) </span><br><span class="line">        <span class="keyword">return</span> sale[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h2><ul>
<li><p>原题链接：<a href="https://leetcode-cn.com/problems/nim-game/">https://leetcode-cn.com/problems/nim-game/</a></p>
</li>
<li><p>题目：</p>
<p>你和你的朋友，两个人一起玩 <a href="https://baike.baidu.com/item/Nim%E6%B8%B8%E6%88%8F/6737105">Nim游戏</a>：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p>
<p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p>
</li>
<li><p>示例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: <span class="literal">false</span> </span><br><span class="line">解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；</span><br><span class="line">     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<p>这是一个easy级别的题目，轮流拿掉1-3个，每次都是最优解而不是随便拿的，通过示例的分析，将二人每那一次作为一组，在一组中，买这时候对应着最少2个石头，最多6个石头，每次都是最优解，<strong>因此先拿的人肯定是要拿最少的石子，而第二个人要想胜利必须拿更多的石子</strong>，由此可以得出，只要组中的石子是4的倍数，那么肯定是先手的人输，推广到整个n中同样如此。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canWinNim</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> n%<span class="number">4</span>==<span class="number">0</span> <span class="keyword">else</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h2><ul>
<li><p>原题链接：<a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/23/">https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/23/</a></p>
</li>
<li><p>题解：给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>
<li>要求使用空间复杂度为 O(1) 的原地算法。</li>
</ul>
</li>
<li><p>分析：</p>
<p>这个题目很简单，右侧移动k步，如果移动的步数和数组的长度相等，那么得到的数组和原来的数组相等。可以对k于数组长度进行取余计算，数组实际移动的步数就是取余之后的结果。</p>
<ul>
<li>方法1：一次移动一个，数组左侧进行插入insert，右侧进行删除del，每次都把数组的最后一个移动0位置，删除新数组的最后一个元素</li>
<li>方法2：使用切片移动，利用extend命令，如果取余结果为m，那么把数组的前length-m个元素添加到数组的后面构成新数组，之后删除新数组的前length-m个元素</li>
</ul>
</li>
<li><p>代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> k&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        length=<span class="built_in">len</span>(nums)    </span><br><span class="line">        step=k%length</span><br><span class="line">        <span class="comment">## 方法1：</span></span><br><span class="line">        <span class="comment"># 后面元素向前移动，一个一个移动，移动之后删除最后一个元素</span></span><br><span class="line">        <span class="comment"># for i in range(step):</span></span><br><span class="line">        <span class="comment">#     nums.insert(0,nums[-1])</span></span><br><span class="line">        <span class="comment">#     del nums[-1]</span></span><br><span class="line">        <span class="comment">## 方法2</span></span><br><span class="line">        <span class="comment"># 使用元素切片，把前面的整体移动到后面之后删除前面部分</span></span><br><span class="line">        nums.extend(nums[:length-step])</span><br><span class="line">        <span class="keyword">del</span> nums[:length-step]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a></h2><ul>
<li><p>题意</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br><span class="line"> 示例 2:</span><br><span class="line"></span><br><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        str_x=<span class="built_in">str</span>(x)</span><br><span class="line">        flage=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> str_x[<span class="number">0</span>]==<span class="string">&quot;-&quot;</span>: </span><br><span class="line">            flage=-<span class="number">1</span></span><br><span class="line">            str_x=str_x[<span class="number">1</span>:]</span><br><span class="line">        reverse=str_x[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> reverse[<span class="number">0</span>]==<span class="string">&quot;0&quot;</span>: </span><br><span class="line">            reverse=reverse[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(reverse) &gt; <span class="number">2</span>**<span class="number">31</span>-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(reverse)*flage</span><br></pre></td></tr></table></figure>

<p>很简单的题目，主要考虑一些注意点就行</p>
<ul>
<li>给的x是0，直接返回</li>
<li>给的x是负数，使用flage来控制</li>
<li>给的x能被10整除，也就是个位是0，反转之后要把0去掉</li>
<li>控制输出数据的范围，只控制正数就可以了</li>
</ul>
</li>
</ul>
<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/">正则表达式匹配</a></h2><ul>
<li><p>题意</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &#x27;.&#x27; 和 &#x27;*&#x27; 的正则表达式匹配。</span><br><span class="line"></span><br><span class="line">&#x27;.&#x27; 匹配任意单个字符</span><br><span class="line">&#x27;*&#x27; 匹配零个或多个前面的那一个元素</span><br><span class="line">所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">s 可能为空，且只包含从 a-z 的小写字母。</span><br><span class="line">p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#x27;*&#x27; 表示零个或多个，这里 &#x27;c&#x27; 为 0 个, &#x27;a&#x27; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>解析</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 这个终止条件不能忘，否则对于给定的p就是空的情况，不出现错误</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:  <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        self.cache=&#123;&#125;</span><br><span class="line">        self.search(s,p)</span><br><span class="line">        <span class="keyword">return</span> self.cache[(s,p)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,s,p</span>):</span><br><span class="line">        <span class="comment"># 终止条件，如果p空，s也是空的能匹配，否则不能匹配</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="comment"># 从缓存查询</span></span><br><span class="line">        <span class="keyword">if</span> (s, p) <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> self.cache[(s, p)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一个字符是否匹配，如果不匹配，如果后面是&quot;*&quot;还有的救，</span></span><br><span class="line">        first_char_match=<span class="built_in">len</span>(s)&gt;<span class="number">0</span> <span class="keyword">and</span> (p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>],<span class="string">&quot;.&quot;</span>&#125;)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(p)&gt;=<span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>]==<span class="string">&quot;*&quot;</span>:</span><br><span class="line">            <span class="comment"># 开始是一个字符，后面跟一个* </span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 对前面字符匹配0次，直接跳过，这时候s不变，p变成p[2:]</span></span><br><span class="line">            cond1=self.search(s,p[<span class="number">2</span>:]) </span><br><span class="line">            <span class="comment"># *对前面字符匹配多次，这时候考虑s[1]已经在first的时候匹配过了，因此从s[1:]开始匹配，p不变</span></span><br><span class="line">            cond2=first_char_match <span class="keyword">and</span> self.search(s[<span class="number">1</span>:],p) </span><br><span class="line">            res= cond1 <span class="keyword">or</span> cond2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 处理的是&quot;.&quot;的情况，&quot;.&quot;对应着任意任意字符，继续匹配，只有一种情况</span></span><br><span class="line">            cond=first_char_match <span class="keyword">and</span> self.search(s[<span class="number">1</span>:],p[<span class="number">1</span>:])</span><br><span class="line">            res=cond</span><br><span class="line">        <span class="comment"># 把结果存入缓存</span></span><br><span class="line">        self.cache[(s,p)]=res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title="字符串转换整数 (atoi)"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">字符串转换整数 (atoi)</a></h2><ul>
<li><p>题意</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">请你来实现一个 atoi 函数，使其能将字符串转换成整数。</span><br><span class="line"></span><br><span class="line">首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</span><br><span class="line"></span><br><span class="line">如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</span><br><span class="line">假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</span><br><span class="line">该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</span><br><span class="line">注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</span><br><span class="line"></span><br><span class="line">在任何情况下，若函数不能进行有效的转换时，请返回 0 。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">本题中的空白字符只包括空格字符 &#x27; &#x27; 。</span><br><span class="line">假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。</span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myAtoi</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">min</span>(<span class="built_in">int</span>(*re.findall(<span class="string">&#x27;^[\+\-]?\d+&#x27;</span>, s.lstrip())), <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>), -<span class="number">2</span>**<span class="number">31</span>)</span><br></pre></td></tr></table></figure>

<p>最好的办法就是正则匹配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">^：匹配字符串开头</span><br><span class="line">[\+\-]：代表一个+字符或-字符</span><br><span class="line">?：前面一个字符可有可无</span><br><span class="line">\d：一个数字</span><br><span class="line">+：前面一个字符的一个或多个</span><br><span class="line">\D：一个非数字字符</span><br><span class="line">*：前面一个字符的0个或多个</span><br><span class="line"></span><br><span class="line">作者：QQqun902025048</span><br><span class="line">链接：https://leetcode-cn.com/problems/string-to-integer-atoi/solution/python-1xing-zheng-ze-biao-da-shi-by-knifezhu/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p><code>max(min(数字, 2**31 - 1), -2**31)</code> 用来防止结果越界</p>
</li>
</ul>
<h2 id="存在重复"><a href="#存在重复" class="headerlink" title="存在重复"></a>存在重复</h2><ul>
<li><p>原题链接：<a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/24/">https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/24/</a></p>
</li>
<li><p>题意：给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析：这道题真的太太太简单了，感觉是考察元组的性质，元组内部元素只能出现一次，根据这个特性直接写出代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">## 一步到位，直接比较元组的长度和原始列表长度，如果相等，则没有重复元素，返回False，否则返回True</span></span><br><span class="line">        <span class="comment"># return not len(set(nums))==len(nums)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">## 麻烦一些，思路大体一致</span></span><br><span class="line">        new=<span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> new:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            new.add(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h2><ul>
<li><p>原题：<a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/25/">https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/25/</a></p>
</li>
<li><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong></p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析：很简单，也是两种方法。</p>
<ul>
<li>只有一个数出现一次，其余都出现了两次，可以利用元组的性质，进行求解，该方法更好理解</li>
<li>使用按照位进行异或运算，因为除了出现一次的其余的全部出现两次，所以出现两次的元素进行异或运算最后都会变为0，只有出现一次的会保留下来，也就是所求的结果</li>
</ul>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">## 方法1</span></span><br><span class="line">        <span class="comment">## (2x+y)=sum1; x+y=sum2;可以得到y=2*sum2-sum1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">sum</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(nums)))-<span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="comment">## 方法2 </span></span><br><span class="line">        <span class="comment">## 转化二进制，按照位异或运算</span></span><br><span class="line">        out=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            out^=i</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>

<h2 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a>两个数组的交集 II</h2><ul>
<li><p>原题链接：<a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/26/">https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/26/</a></p>
</li>
<li><p>题意：给定两个数组，编写一个函数来计算它们的交集。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出: [2,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出: [4,9]</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul>
</li>
<li><p>分析：要求不用考虑输出结果的顺序，那么直接求在两个数组中的元素</p>
</li>
<li><p>代码：两种思路：</p>
<ul>
<li><ol>
<li>直接按照题意，找出长度较短的数组，查看内部元素是否在长数组中，时间复杂度$n^2$</li>
</ol>
</li>
<li><ol start="2">
<li>使用字典的方式，存储一个数组中的值以及对应出现的次数，之后另一个数组查看是否在该字典中，如果存在，字典中该key对应的value减去1。时间复杂度$nlog(n)$</li>
<li>利用字典形式，将nums1和num2都出现的次数都存储在字典中，字典的value为列表形式，时间复杂度为$log(n)$</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersect</span>(<span class="params">self, nums1, nums2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        方法1：</span></span><br><span class="line"><span class="string">            直接按照题意，遍历长度短的数组，</span></span><br><span class="line"><span class="string">            看内部元素是否在短的数组内，如果存在，删除长的数组内的该元素</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># out=[]</span></span><br><span class="line">        <span class="comment"># length1=len(nums1)</span></span><br><span class="line">        <span class="comment"># length2=len(nums2)</span></span><br><span class="line">        <span class="comment"># if length1&lt;length2:</span></span><br><span class="line">        <span class="comment">#     sm=nums1</span></span><br><span class="line">        <span class="comment">#     bi=nums2</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     sm=nums2</span></span><br><span class="line">        <span class="comment">#     bi=nums1</span></span><br><span class="line">        <span class="comment"># for i in sm:</span></span><br><span class="line">        <span class="comment">#     if i in bi:</span></span><br><span class="line">        <span class="comment">#         out.append(i)</span></span><br><span class="line">        <span class="comment">#         bi.remove(i)</span></span><br><span class="line">        <span class="comment"># return out</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        方法2：</span></span><br><span class="line"><span class="string">            使用字典</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#         dire=&#123;&#125;</span></span><br><span class="line"><span class="comment">#         out=[]</span></span><br><span class="line"><span class="comment">#         for i in nums1:</span></span><br><span class="line"><span class="comment">#             if i not in dire:</span></span><br><span class="line"><span class="comment">#                 dire[i]=0</span></span><br><span class="line"><span class="comment">#             dire[i]+=1</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">#         for i in nums2:</span></span><br><span class="line"><span class="comment">#             if i in dire and dire[i]&gt;0:</span></span><br><span class="line"><span class="comment">#                 dire[i]-=1</span></span><br><span class="line"><span class="comment">#                 out.append(i)</span></span><br><span class="line"><span class="comment">#         return out</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        方法3：</span></span><br><span class="line"><span class="string">            排名前列的算法，同样是利用字典的方法，不过非常巧妙</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        maps=&#123;&#125;</span><br><span class="line">        out=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> maps:</span><br><span class="line">                maps[i]=[<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maps[i][<span class="number">0</span>]+=<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> maps:</span><br><span class="line">                maps[i][<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> maps:</span><br><span class="line">            <span class="keyword">if</span> maps[i][<span class="number">1</span>]&gt;<span class="number">0</span>:</span><br><span class="line">                howmany=<span class="built_in">min</span>(maps[i])</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(howmany):</span><br><span class="line">                    out.append(i)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>

<h2 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h2><ul>
<li><p>原题链接：<a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/27/">https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/27/</a></p>
</li>
<li><p>题意：给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析：两种思路</p>
<ol>
<li><p>直接在数组上进行操作，进行输入数组原地修改，空间复杂度$O(1)$时间复杂度$O(n)$，更优选择</p>
</li>
<li><p>把数组转换成数字，进行+1操作之后再转换回去，空间O2，时间On</p>
</li>
</ol>
</li>
<li><p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plusOne</span>(<span class="params">self, digits</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">##方法1 直接按照加法法则从后向前移动,</span></span><br><span class="line">        length=<span class="built_in">len</span>(digits)</span><br><span class="line">        count=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">1</span>,-length-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            s=digits[idx]+count</span><br><span class="line">            cur,res=s%<span class="number">10</span>,s//<span class="number">10</span></span><br><span class="line">            count=res</span><br><span class="line">            digits[idx]=cur</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> count:</span><br><span class="line">            digits.insert(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> digits</span><br><span class="line">        <span class="comment">## 方法2</span></span><br><span class="line">        <span class="comment">## 把数组转换成字符串</span></span><br><span class="line">        <span class="comment"># ori=int(&#x27;&#x27;.join(str(i) for i in digits))</span></span><br><span class="line">        <span class="comment"># ori+=1</span></span><br><span class="line">        <span class="comment"># out=str(ori)</span></span><br><span class="line">        <span class="comment"># return list(int(i) for i in out)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h2><ul>
<li><p>原题链接：<a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/28/">https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/28/</a></p>
</li>
<li><p>题意：给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>:</p>
<ol>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ol>
</li>
<li><p>分析：遍历整个数组，遍历的次数为数组的长度，当遇到为0时，append一个0，并且删除当前值，并且继续从当前值遍历</p>
</li>
<li><p>代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        count表示遍历的次数，index代表数组的索引，如果不添加遍历次数的限制，会出现死循环情况</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        idx=<span class="number">0</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> count&lt;<span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[idx]==<span class="number">0</span>:</span><br><span class="line">                nums.append(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">del</span> nums[idx]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                idx+=<span class="number">1</span></span><br><span class="line">            count+=<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><ul>
<li><p>原题链接：<a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/29/">https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/29/</a></p>
</li>
<li><p>题意：给定一个整数数组和一个目标值，找出数组中和为目标值的<strong>两个</strong>数。</p>
<p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p>
<p><strong>示例:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析：<strong>两数之和为target，可以认为一个为a，另一个为target-a</strong></p>
<ul>
<li>使用哈希的方式，假设当前值为cur，key为(target-cur)，对应的value为idx</li>
</ul>
</li>
<li><p>代码：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 哈希方法</span></span><br><span class="line">        maps=&#123;&#125;</span><br><span class="line">        out=[]</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[idx] <span class="keyword">not</span> <span class="keyword">in</span> maps:</span><br><span class="line">                maps[target-nums[idx]]=[idx]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maps[nums[idx]].append(idx)</span><br><span class="line">                <span class="keyword">return</span> maps[nums[idx]]</span><br><span class="line">        </span><br><span class="line">                </span><br></pre></td></tr></table></figure>

<h2 id="三数之和"><a href="#三数之和" class="headerlink" title=" 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/"> 三数之和</a></h2><ul>
<li><p>题意</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</span><br><span class="line"></span><br><span class="line">注意：答案中不可以包含重复的三元组。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>解析</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> first <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> first &gt; <span class="number">0</span> <span class="keyword">and</span> nums[first] == nums[first - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># c 对应的指针初始指向数组的最右端</span></span><br><span class="line">            third = n - <span class="number">1</span></span><br><span class="line">            target = -nums[first]</span><br><span class="line">            <span class="comment"># 枚举 b</span></span><br><span class="line">            <span class="keyword">for</span> second <span class="keyword">in</span> <span class="built_in">range</span>(first + <span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># 需要和上一次枚举的数不相同</span></span><br><span class="line">                <span class="keyword">if</span> second &gt; first + <span class="number">1</span> <span class="keyword">and</span> nums[second] == nums[second - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">                <span class="keyword">while</span> second &lt; third <span class="keyword">and</span> nums[second] + nums[third] &gt; target:</span><br><span class="line">                    third -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">                <span class="comment"># 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">                <span class="keyword">if</span> second == third:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> nums[second] + nums[third] == target:</span><br><span class="line">                    ans.append([nums[first], nums[second], nums[third]])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>直接按照题意去做，先做序列进行排序，参考两个数之和的思路，先枚举第一个数，剩下的两个数之和就是第一个数的相反数，因为题意上有条件，不重复的三元组，如果使用两数之和的思路没办法控制这个条件，这里使用前后指针的方式实现。</p>
</li>
</ul>
<h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h2><ul>
<li><p>原题链接<a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p>
</li>
<li><p>题解：给定两个<strong>非空</strong>链表来表示两个非负整数。位数按照<strong>逆序</strong>方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>
</li>
</ul>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure>

<ul>
<li>分析：该题一目了然，使用链表的形式模拟了十进制加法运算。根节点代表低位，next代表了高位，直至给定的两个链表全部加完，即next为none。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        temp=out=ListNode(<span class="literal">None</span>)</span><br><span class="line">        _<span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> _<span class="built_in">sum</span>:</span><br><span class="line">            _<span class="built_in">sum</span>+=(l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span>)+(l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 对_sum进行取余和取整，余数赋值给当前，整数留下，并向前移动一位</span></span><br><span class="line">            out.<span class="built_in">next</span>=ListNode(_<span class="built_in">sum</span>%<span class="number">10</span>)</span><br><span class="line">            out=out.<span class="built_in">next</span></span><br><span class="line">            l1=l1.<span class="built_in">next</span> <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            l2=l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            _<span class="built_in">sum</span>=_<span class="built_in">sum</span>//<span class="number">10</span></span><br><span class="line">        <span class="comment"># out和temp是同一个起点，在上述过程，一直在调用out.next，并对链表每个节点赋值</span></span><br><span class="line">        <span class="comment"># 最终要得到完成的链表，因此，此处返回temp.out，也就是从最开始初始化的位置的next</span></span><br><span class="line">        <span class="keyword">return</span> temp.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<hr><img src="/2018/11/06/LeetCode/add_2.png" class="" title="两数相加提交记录">

<h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><ul>
<li><p>原题链接 <a href="https://leetcode-cn.com/problems/min-stack/">https://leetcode-cn.com/problems/min-stack/</a></p>
</li>
<li><p>题意</p>
<p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li>push(x) – 将元素 x 推入栈中。</li>
<li>pop() – 删除栈顶的元素。</li>
<li>top() – 获取栈顶元素。</li>
<li>getMin() – 检索栈中的最小元素。</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<p>这道题目考察的堆栈的理解，对于堆栈结构使用的是<strong>先进后出</strong>的策略，类似于摞盘子，先放的盘子是在最下面，后方的盘子在最上面，取盘子的时候先取的都是最后放的，</p>
<ul>
<li><p>push操作</p>
<p>将元素压入栈中，也就是为栈append一个元素</p>
</li>
<li><p>pop操作</p>
<p>删除栈顶的元素，也就是对栈进行pop操作，删除最后添加的元素</p>
</li>
<li><p>top</p>
<p>获取栈顶匀速，也就是返回栈中最后添加的元素</p>
</li>
<li><p>getMin</p>
<p>获取栈的最小元素，并且是在常数时间内，也就是不能说那个min()的方式，因为这种方式的时间复杂度为$O(n)$，题目要求的是$O(1)$，基于此，可以创建一个临时数组只用来存储最小的元素，当进行getMin操作的时候，返回该临时数组的最后一个元素</p>
</li>
</ul>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.data=[]</span><br><span class="line">        self.min_stack=[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.data.append(x)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.min_stack:</span><br><span class="line">            self.min_stack.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> x&lt;self.min_stack[-<span class="number">1</span>]:</span><br><span class="line">                self.min_stack.append(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.min_stack.append(self.min_stack[-<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">        self.data.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.data[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure>

<p><strong>Note</strong></p>
<p>这里有一个要注意的地方，实际上对于使用数组结构模拟栈的结构形式，有两种实现方式</p>
<ul>
<li><p>insert,del</p>
<p>对于push操作，使用insert(0,x)进行，也就是新元素插入数组的顶部</p>
<p>对于pop操作，删除的是最近添加的元素，使用del data[0]</p>
</li>
<li><p>Apped,pop</p>
<p>对于push操作，使用append(X)，将新元素添加到数组的尾部</p>
<p>对于pop操作，直接使用data.pop()</p>
</li>
</ul>
<p>比较这两种方法，对于第一种的insert+del的方式，元素压入和删除元素，数组中的其他元素都要顺序后移或前移一位，而第二中的append+pop的方式则不会这样，因此在操作时间上，第二种方法是更优的。对于数组结构，都要优先使用尾部添加或删除的方式。</p>
<h2 id="3的幂"><a href="#3的幂" class="headerlink" title="3的幂"></a>3的幂</h2><ul>
<li><p>原题链接 <a href="https://leetcode-cn.com/problems/power-of-three/">https://leetcode-cn.com/problems/power-of-three/</a></p>
</li>
<li><p>题意</p>
<p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</p>
</li>
<li><p>示例</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 27</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 45</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进阶：</strong><br>你能不使用循环或者递归来完成本题吗？</p>
</li>
<li><p>分析</p>
<ul>
<li><p>递归方法</p>
<p>简单易行，每次当前数字和3取余</p>
</li>
</ul>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfThree</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> n&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> n%<span class="number">3</span>!=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            n/=<span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="二叉树的坡度"><a href="#二叉树的坡度" class="headerlink" title="二叉树的坡度"></a>二叉树的坡度</h2><ul>
<li><p>原题链接 <a href="https://leetcode-cn.com/problems/binary-tree-tilt/">https://leetcode-cn.com/problems/binary-tree-tilt/</a></p>
</li>
<li><p>题意</p>
<p>给定一个二叉树，计算<strong>整个树</strong>的坡度。</p>
<p>一个树的<strong>节点的坡度</strong>定义即为，该节点左子树的结点之和和右子树结点之和的<strong>差的绝对值</strong>。空结点的的坡度是0。</p>
<p><strong>整个树</strong>的坡度就是其所有节点的坡度之和。</p>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">         1</span><br><span class="line">       /   \</span><br><span class="line">      2     3</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">结点的坡度 2 : 0</span><br><span class="line">结点的坡度 3 : 0</span><br><span class="line">结点的坡度 1 : |2-3| = 1</span><br><span class="line">树的坡度 : 0 + 0 + 1 = 1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意:</strong></p>
</li>
</ul>
<ol>
<li>任何子树的结点的和不会超过32位整数的范围。</li>
<li>坡度的值不会超过32位整数的范围。</li>
</ol>
<ul>
<li><p>分析</p>
<p>根据每个节点的坡度的定义，对于某个节点当前节点和左右子树之和为<code>left+right+root.val</code>，依次为递归的返回式，进行后续遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_sum</span>(<span class="params">root</span>):</span><br><span class="line">	left=find_sum(root.left)</span><br><span class="line">	right=find_sum(root.right)</span><br><span class="line">	out+=<span class="built_in">abs</span>(left-right)</span><br><span class="line">	<span class="keyword">return</span> root.val+left+right</span><br></pre></td></tr></table></figure>

<p>通过该遍历得到每个节点计算得到的<code>left-right</code>之和，得到的out即为所求，因此，整个代码可以为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTilt</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.out = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find_sum</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = find_sum(root.left)</span><br><span class="line">            right = find_sum(root.right)</span><br><span class="line">            <span class="comment"># 计算坡度，左右节点相减</span></span><br><span class="line">            self.out += <span class="built_in">abs</span>(left - right)</span><br><span class="line">            <span class="comment"># 返回以当前的节点为根节点的所有节点之和,进入下一步的递归</span></span><br><span class="line">            <span class="comment"># root.val + left + right构成一个完成的节点</span></span><br><span class="line">            <span class="keyword">return</span> root.val + left + right</span><br><span class="line">        find_sum(root)</span><br><span class="line">        <span class="keyword">return</span> self.out</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="寻找两个有序数组的中位数"><a href="#寻找两个有序数组的中位数" class="headerlink" title="寻找两个有序数组的中位数"></a>寻找两个有序数组的中位数</h2><ul>
<li><p>原题链接 <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p>
</li>
<li><p>题意</p>
<p>给定两个大小为 m 和 n 的有序数组 <code>nums1</code> 和 <code>nums2</code>。</p>
<p>请你找出这两个有序数组的中位数，**并且要求算法的时间复杂度为 O(log(m + n))**。</p>
<p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p>
</li>
<li><p>示例</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<p>先说中位数的定义</p>
<blockquote>
<p>對於有限的數集，可以通過把所有觀察值高低排序後找出正中間的一個作爲中位數。如果觀察值有偶數個，則中位數不唯一，通常取最中間的兩個數值的<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E5%9D%87%E6%95%B0">平均數</a>作爲中位數。</p>
</blockquote>
<p>由此可以看到，对于中位数，针对数组长度的奇偶数不同而计算方法不同</p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedianSortedArrays</span>(<span class="params">self, nums1, nums2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        l1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        l2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        Length = <span class="built_in">int</span>(l1 + l2)</span><br><span class="line">        </span><br><span class="line">        nums = nums1 + nums2</span><br><span class="line">        nums.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果合并数组为偶数，那么中位数就是中间位置的两个数之和/2</span></span><br><span class="line">        <span class="keyword">if</span> (Length % <span class="number">2</span>) == <span class="number">0</span>:</span><br><span class="line">            out = (nums[<span class="built_in">int</span>(Length/<span class="number">2</span>)] + nums[<span class="built_in">int</span>((Length / <span class="number">2</span>) - <span class="number">1</span>)]) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果长度为奇数，中位数对应的索引为长度/2</span></span><br><span class="line">            out = nums[<span class="built_in">int</span>((Length - <span class="number">1</span>) / <span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>

<h2 id="复原ip地址"><a href="#复原ip地址" class="headerlink" title="复原ip地址"></a>复原ip地址</h2><ul>
<li><p>原题链接：<a href="https://leetcode-cn.com/explore/interview/card/bytedance/242/string/1044/">https://leetcode-cn.com/explore/interview/card/bytedance/242/string/1044/</a></p>
</li>
<li><p>题意</p>
<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
</li>
<li><p>示例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;25525511135&quot;</span></span><br><span class="line">输出: [<span class="string">&quot;255.255.11.135&quot;</span>, <span class="string">&quot;255.255.111.35&quot;</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<p>本体考察的是图搜索算法，分为广度优先搜索和深度优先搜索</p>
<p>对于ip的格式</p>
<ul>
<li>ip分为4断格式，每段之间数字为0–255之间的数字</li>
<li>数字不能以0开头，除了0本身</li>
</ul>
<p>对于该判断可以得到条件函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isvalid</span>(<span class="params">s</span>):</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">str</span>(<span class="built_in">int</span>(s))==s <span class="keyword">and</span> <span class="number">0</span>&lt;=<span class="built_in">int</span>(s)&lt;=<span class="number">255</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>对于每个字段之间，可能的数字数量为为1，2，3，将符合条件字符串分段存储，如果最后将给定的字符串分割完毕并且满足条件的分段字符串为4段，可以得到满足条件的一个分割ip地址，使用递归的方式进行依次调用查找函数。</p>
</li>
<li><p>代码</p>
<ul>
<li>递归方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restoreIpAddresses</span>(<span class="params">self, s</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            :type s: str</span></span><br><span class="line"><span class="string">            :rtype: List[str]</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># 边界条件，大于12个或者小于4个无法构成有效ip地址</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">12</span> <span class="keyword">or</span> <span class="built_in">len</span>(s)&lt;<span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            res = []</span><br><span class="line">            dfs(s, [], res)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isvalid</span>(<span class="params">s</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=<span class="built_in">int</span>(s)&lt;=<span class="number">255</span> <span class="keyword">and</span> <span class="built_in">str</span>(<span class="built_in">int</span>(s))==s:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">s, path, res</span>):</span><br><span class="line">			<span class="comment"># 剪枝条件，如果剩余的有效的ip字符段数量无法满足最大的字符数量条件退出该条路径</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; (<span class="number">4</span> - <span class="built_in">len</span>(path)) * <span class="number">3</span> <span class="keyword">or</span> <span class="built_in">len</span>(s)&lt;<span class="number">4</span>-<span class="built_in">len</span>(path):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">           	<span class="comment"># 如果s被查找完毕并且找的ip字符段数量满足收敛条件，添加到res中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="built_in">len</span>(path) == <span class="number">4</span>:</span><br><span class="line">                res.append(<span class="string">&#x27;.&#x27;</span>.join(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 每个ip字段有可能为1，2，3个</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">                <span class="comment"># 判断剩余的s是否满足条件</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="built_in">len</span>(s):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 是否满足ip格式</span></span><br><span class="line">                <span class="keyword">if</span> isvalid(s[:i]):</span><br><span class="line">                    <span class="comment"># 如果满足条件，path中存储满足条件的字符段并重复调用寻找函数path+[s[:i]]</span></span><br><span class="line">                    <span class="comment"># 寻找区间缩小为剩余的字符串s[:i]</span></span><br><span class="line">                    dfs(s[i:],path+[s[:i]],res)        </span><br></pre></td></tr></table></figure>

<hr>

<ul>
<li>对于递归的方式，由于需要重复对函数本身进行调用，因此容易造成内存溢出，<strong>将递归的方式修改成迭代方式，更加直白，类似于暴力搜索的方式</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restoreIpAddresses</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isvalid</span>(<span class="params">s</span>):</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">and</span>  <span class="number">0</span>&lt;=<span class="built_in">int</span>(s)&lt;=<span class="number">255</span> <span class="keyword">and</span> <span class="built_in">str</span>(<span class="built_in">int</span>(s))==s:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">     </span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">            f1=s[:i]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isvalid(f1):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+<span class="number">4</span>):</span><br><span class="line">                f2=s[i:j]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> isvalid(f2):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j+<span class="number">1</span>,j+<span class="number">4</span>):</span><br><span class="line">                    f3,f4=s[j:k],s[k:]</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> isvalid(f3) <span class="keyword">or</span> <span class="keyword">not</span> isvalid(f4):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    res+=[f1+<span class="string">&#x27;.&#x27;</span>+f2+<span class="string">&#x27;.&#x27;</span>+f3+<span class="string">&#x27;.&#x27;</span>+f4]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="反转字符串的单词"><a href="#反转字符串的单词" class="headerlink" title="反转字符串的单词"></a>反转字符串的单词</h2><ul>
<li><p>链接：<a href="https://leetcode-cn.com/explore/interview/card/bytedance/242/string/1011/">https://leetcode-cn.com/explore/interview/card/bytedance/242/string/1011/</a></p>
</li>
<li><p>题意</p>
<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
</li>
<li><p>示例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;the sky is blue&quot;</span>,</span><br><span class="line">输出: <span class="string">&quot;blue is sky the&quot;</span>.</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明</p>
<ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
</li>
<li><p><strong>进阶:</strong> 请选用C语言的用户尝试使用 <em>O</em>(1) 空间复杂度的原地解法。</p>
</li>
<li><p>分析</p>
<p>对于python来说，直接进行字符串分割，然后反转列表输出字符串</p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>  </span><br><span class="line">        <span class="comment"># 一步步来</span></span><br><span class="line">        <span class="comment"># s=s.strip() # 去除字符串前后声明符合</span></span><br><span class="line">        <span class="comment"># s=s.split() # 分割字符串</span></span><br><span class="line">        <span class="comment"># s.reverse() # 反转列表</span></span><br><span class="line">        <span class="comment"># s=&#x27; &#x27;.join(s) # 生成字符串</span></span><br><span class="line">        <span class="comment"># return s</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 一步到位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">reversed</span>(s.strip().split()))</span><br></pre></td></tr></table></figure>

<h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><ul>
<li><p>题意</p>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p>
</li>
<li><p>示例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<p>时间复杂度是$O(\log n)$首先想到的就是二分查找法，对于该题目，由于涉及两个查找，首先是对单调递增区间的查找，之后是在单调区间内的查找</p>
<ul>
<li><p>对于单调递增权健的查找</p>
<p>实际上就是找到两个单调区间的临界点，该临近点的右侧是单调递增区间并且，该临界点大于右侧区间的所有点，该临界点的左侧也是单调递增区间，同样，该临界点也大于左侧的区间内的左右点，使用二分查找的方式确定该临界点，确定右侧的单调区间，设置left,right对应右侧单调区间的起始索引，</p>
<ul>
<li>如果中值大于右侧的值，那么右侧区间在在中值的更右侧，此时left&#x3D;mid+1</li>
<li>如果中值小于右侧的值，那么该中值的位置位于右侧的单调区间内，此时，right&#x3D;mid</li>
</ul>
</li>
<li><p>找到单调区间之后可以使用标准的二分查找方式确定目标值的索引</p>
</li>
</ul>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># log(n)标准的二分查找</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">binarysearch</span>(<span class="params">tar,num</span>):</span><br><span class="line">            index=-<span class="number">1</span></span><br><span class="line">            lf=<span class="number">0</span></span><br><span class="line">            rg=<span class="built_in">len</span>(num)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> lf &lt;=rg:</span><br><span class="line">                mid=(rg+lf)//<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> tar&gt;num[mid]:</span><br><span class="line">                    <span class="comment"># 如果中间值小于目标值，搜索中间值右侧区间，left=mid+1</span></span><br><span class="line">                    lf=mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> tar&lt;num[mid]:</span><br><span class="line">                    <span class="comment"># 如果中间值大于目标值，搜索中间值左侧的区间，rigjt=mid-1</span></span><br><span class="line">                    rg=mid-<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    index=mid</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> index  </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">0</span>]==target:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 查找右侧单调区间起始索引点</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;right:</span><br><span class="line">            mid=(right+left)//<span class="number">2</span></span><br><span class="line">            <span class="comment"># 反转之后右侧是递增的，找到右侧的单调区间的起始索引值left</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&gt;nums[right]:</span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line">        turned=left</span><br><span class="line">        find_para=nums[:turned]</span><br><span class="line">        res=binarysearch(target,find_para)</span><br><span class="line">        <span class="comment">#在左侧区间没找到</span></span><br><span class="line">        <span class="keyword">if</span> res==-<span class="number">1</span>:</span><br><span class="line">            res=binarysearch(target,nums[turned:])</span><br><span class="line">            <span class="keyword">if</span> res!=-<span class="number">1</span>:</span><br><span class="line">                res+=turned</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">                </span><br></pre></td></tr></table></figure>

<h2 id="第k个排列"><a href="#第k个排列" class="headerlink" title="第k个排列"></a>第k个排列</h2><ul>
<li><p>原题链接 <a href="https://leetcode-cn.com/problems/permutation-sequence/">https://leetcode-cn.com/problems/permutation-sequence/</a></p>
</li>
<li><p>题意</p>
<p>给出集合 <code>[1,2,3,…,*n*]</code>，其所有元素共有 <em>n</em>! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 <em>n</em> &#x3D; 3 时, 所有排列如下：</p>
<ol>
<li><code>&quot;123&quot;</code></li>
<li><code>&quot;132&quot;</code></li>
<li><code>&quot;213&quot;</code></li>
<li><code>&quot;231&quot;</code></li>
<li><code>&quot;312&quot;</code></li>
<li><code>&quot;321&quot;</code></li>
</ol>
<p>给定 <em>n</em> 和 <em>k</em>，返回第 <em>k</em> 个排列。</p>
</li>
<li><p><strong>说明：</strong></p>
</li>
<li><p>给定 <em>n</em> 的范围是 [1, 9]。</p>
</li>
<li><p>给定 <em>k</em> 的范围是[1,  <em>n</em>!]。</p>
</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 3, k = 3</span><br><span class="line">输出: <span class="string">&quot;213&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 4, k = 9</span><br><span class="line">输出: <span class="string">&quot;2314&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>分析</p>
<p>参考<a href="https://cloud.tencent.com/developer/article/1335755">https://cloud.tencent.com/developer/article/1335755</a></p>
<p>本题目考察的也是一种回溯法，但是直接使用递归的方法计算全排列然后再拿到全排列数组中的第k个元素会存在超时的问题，对于得到字符串全排列的方法为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPermutation</span>(<span class="params">self, n, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        s=<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)))</span><br><span class="line">        <span class="comment"># 迭代方法</span></span><br><span class="line">        self.res=[s]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">Permutation</span>(<span class="params">ss</span>):</span><br><span class="line">            res=[]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(ss) &lt;= <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> ss</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ss)):</span><br><span class="line">                <span class="comment"># 使用map和lambda函数</span></span><br><span class="line">                <span class="comment"># 递归的计算ss[:i] + ss[i+1:]</span></span><br><span class="line">                <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">map</span>(<span class="keyword">lambda</span> x:ss[i] + x, Permutation(ss[:i] + ss[i+<span class="number">1</span>:])):</span><br><span class="line">                    res.append(n)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        self.res=Permutation(s)</span><br><span class="line">        <span class="keyword">return</span> self.res[k-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>对于递归的方法计算复杂度是在是太高，可以稍微修改一下为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPermutation</span>(<span class="params">self, n, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        s=<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">ss, res, path</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">                <span class="comment"># 如果ss为空，那么将前面得到的path存入到res中</span></span><br><span class="line">                res.append(path)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ss)):</span><br><span class="line">                    <span class="comment"># 将当前字符串添加入path中，并递归计算剩余的元素</span></span><br><span class="line">                    helper(ss[:i] + ss[i+<span class="number">1</span>:], res, path + ss[i])</span><br><span class="line">        self.res=[]</span><br><span class="line">        helper(s, self.res, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res[k-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>上面两个是基于先计算字符串的全排列然后再返回所有全排列的第k-1个元素的思路，这两种方法都会存在运算超时的问题，肯定是有问题的。</p>
<p>重新分析，</p>
<ul>
<li><p>对于n个数字，范围是1-9，那么全排列的可能性为n!</p>
</li>
<li><p>加入给定n&#x3D;4，那么数字为1234，并且要求的k是得到的所有排列从小到大排列之后的第k个元素</p>
<ul>
<li>1开头+(2,3,4)全排列</li>
<li>2开头+(1,3,4)全排列</li>
<li>。。。<ul>
<li>12开头+(3,4全排列)</li>
<li>13开头+(2,4)全排列</li>
</ul>
</li>
</ul>
<p>可以逐位计算得到最终的字符串</p>
</li>
<li><p>第一位元素对应着(k&#x2F;(n-1)!)，第二位对应着(k%(n-1)!)&#x2F;(n-2)!，以此类推</p>
</li>
</ul>
<p>代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPermutation</span>(<span class="params">self, n, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># n个数字存在n!全排列</span></span><br><span class="line">        <span class="comment"># 每个数字开头，存在(n-1)!种全排列</span></span><br><span class="line">        nums = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> nums)</span><br><span class="line">        fact = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 对于第一个个字开头的情况存在着n-1种全排列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            fact *= i</span><br><span class="line">        </span><br><span class="line">        _<span class="built_in">round</span> = n - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 求的是第k个元素，对于列表中对应着k-1的索引</span></span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">        Res = []</span><br><span class="line">        <span class="comment"># 找到排列中的n个元素</span></span><br><span class="line">        <span class="comment"># 对于每个元素，根据k的值进行计算</span></span><br><span class="line">        <span class="comment"># 第一个元素，对应着(n-1)!种全排列可能，使用int(k/(n-1)!)得到第一位的元素对应的nums中的位置</span></span><br><span class="line">        <span class="comment"># 第二个元素，对应着(n-2)!种全排列可能，使用int(k/(n-2)!)得到第二位元素对应的nums中的位置</span></span><br><span class="line">        <span class="comment"># 由此，一次类推，逐渐求出每位的元素</span></span><br><span class="line">        <span class="keyword">while</span> _<span class="built_in">round</span> &gt;= <span class="number">0</span>:</span><br><span class="line">            index = <span class="built_in">int</span>(k / fact)</span><br><span class="line">            <span class="comment"># 对k取余，得到下一位对应的排列可能的数量</span></span><br><span class="line">            k %= fact</span><br><span class="line">            <span class="comment"># 当前位元素在nums中的位置，并删除nums中的这个元素</span></span><br><span class="line">            Res.append(nums[index])</span><br><span class="line">            nums.remove(nums[index])</span><br><span class="line">            <span class="comment"># 如果还有下一位要进行计算，那么对fact进行更新，上一位存在(n-1)!种可能</span></span><br><span class="line">            <span class="comment"># 那么下一位存在(n-2)!种可能</span></span><br><span class="line">            <span class="keyword">if</span> _<span class="built_in">round</span> &gt; <span class="number">0</span>:</span><br><span class="line">                fact /= _<span class="built_in">round</span></span><br><span class="line">            _<span class="built_in">round</span> -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> Res)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="朋友圈"><a href="#朋友圈" class="headerlink" title="朋友圈"></a>朋友圈</h2><ul>
<li><p>原题链接 <a href="https://leetcode-cn.com/explore/interview/card/bytedance/243/array-and-sorting/1036/">https://leetcode-cn.com/explore/interview/card/bytedance/243/array-and-sorting/1036/</a></p>
</li>
<li><p>题意</p>
<p>班上有 <strong>N</strong> 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p>
<p>给定一个 <strong>N * N</strong> 的矩阵 <strong>M</strong>，表示班级中学生之间的朋友关系。如果M[i][j] &#x3D; 1，表示已知第 i 个和 j 个学生<strong>互为</strong>朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p>
</li>
<li><p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">输出: 2 </span><br><span class="line">说明：已知学生0和学生1互为朋友，他们在一个朋友圈。</span><br><span class="line">第2个学生自己在一个朋友圈。所以返回2。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,1],</span><br><span class="line"> [0,1,1]]</span><br><span class="line">输出: 1</span><br><span class="line">说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意</p>
<ol>
<li>N 在[1,200]的范围内。</li>
<li>对于所有学生，有M[i][i] &#x3D; 1。</li>
<li>如果有M[i][j] &#x3D; 1，则有M[j][i] &#x3D; 1。</li>
</ol>
</li>
<li><p>分析</p>
<p>对于本题来说，有三种解体方法，</p>
<ul>
<li>DFS</li>
<li>BFS</li>
<li>查并集</li>
</ul>
<p>对于这种搜索的问题，要优先考虑图搜索的相关算法，在图搜索中包含深度优先搜索DFS，广度优先搜索BFS。</p>
<ul>
<li><p>广度优先搜索</p>
<p>BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。<br>BFS属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">算法流程：</span><br><span class="line">    1.首先将根节点放入队列中。</span><br><span class="line">    2.从队列中取出第一个节点，并检验它是否为目标。如果找到目标，则结束搜寻并回传结果。否则将它所有	  尚未检验过的直接子节点加入队列中。</span><br><span class="line">    3. 若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</span><br><span class="line">    重复步骤2。</span><br></pre></td></tr></table></figure>
</li>
<li><p>深度优先搜索</p>
<p>它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">算法流程</span><br><span class="line">	1.访问顶点v；</span><br><span class="line">	2.依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；</span><br><span class="line">	3.若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶	  点均被访问过为止。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在图论中，能使用BFS的一般也能使用DFS。</p>
<ul>
<li>DFS代码</li>
</ul>
<p>对于本题目，一共存在n个人，使用深度优先搜索的方法，首先设置一个状态列表，从每个节点出发，如果这个节点不再状态列表内，那么查找该人的朋友圈，关于该人朋友圈的查找方法为，如果这个人不在已经状态列表中，并且这个人和查找的节点的人存在朋友关系，那么把这个人加入到状态信息中并且继续查找这个人对饮的朋友信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findCircleNum</span>(<span class="params">self, M</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type M: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cnt, N = <span class="number">0</span>, <span class="built_in">len</span>(M)</span><br><span class="line">        vset = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">n</span>):</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="keyword">if</span> M[n][x] <span class="keyword">and</span> x <span class="keyword">not</span> <span class="keyword">in</span> vset:</span><br><span class="line">                    vset.add(x)</span><br><span class="line">                    dfs(x)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> vset:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                dfs(x)</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<ul>
<li>BFS代码</li>
</ul>
<p>如果是广度优先搜索的方法，需要借助一个队列来协助，遍历</p>
<p>（1）可以先找到一个人，把这个人的所有朋友都入队。<br>（2）然后依次出队，把朋友的朋友都入队，已经入过队列的，则不再入队。<br>（3）直到不再有朋友入队，而且已经出队完成，说明现在已经组成了一个朋友圈。<br>（4）然后把剩下的没被分到朋友圈里面的，同学，再次入队，进行下一个朋友圈的计算，依次循环直到结束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findCircleNum</span>(<span class="params">self, M</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type M: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cnt, N = <span class="number">0</span>, <span class="built_in">len</span>(M)</span><br><span class="line">        vset = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># bfs搜索算法</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">n</span>):</span><br><span class="line">            <span class="comment"># 将该人添加到队列中</span></span><br><span class="line">            q = [n]</span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                <span class="comment"># 依次出队，第一次出队的是节点本身</span></span><br><span class="line">                <span class="comment"># 找到和该节点满足朋友关系的人之后再找这些朋友的朋友</span></span><br><span class="line">                n = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 找到该节点人对应的所有朋友，</span></span><br><span class="line">                <span class="comment"># 将朋友关系的添加到队列中，此外在将此添加到状态列表中</span></span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                    <span class="comment"># 如果满足朋友关系但是该人已经在状态列表中，那么这个人不再入队列</span></span><br><span class="line">                    <span class="comment"># 目的是剪枝去重，如果a和bc都是朋友关系，那么不再查找bc之间的关系</span></span><br><span class="line">                    <span class="keyword">if</span> M[n][x] <span class="keyword">and</span> x <span class="keyword">not</span> <span class="keyword">in</span> vset:</span><br><span class="line">                        vset.add(x) </span><br><span class="line">                        q.append(x)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> vset:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 对该人进行bfs搜索</span></span><br><span class="line">                bfs(x)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>

<ul>
<li>查并集</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findCircleNum</span>(<span class="params">self, M</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type M: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        N = <span class="built_in">len</span>(M)</span><br><span class="line">        <span class="comment"># 假设每个人是相互独立的</span></span><br><span class="line">        f = <span class="built_in">list</span>(<span class="built_in">range</span>(N))</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> f[x] != x: </span><br><span class="line">                x = f[x]</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="comment"># 向前搜索</span></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(x + <span class="number">1</span>, N):</span><br><span class="line">                <span class="comment"># 如果满足朋友关系</span></span><br><span class="line">                <span class="keyword">if</span> M[x][y]: </span><br><span class="line">                    <span class="comment"># 满足朋友关系的话，将f中的x的节点的值进行更新</span></span><br><span class="line">                    <span class="comment"># 更新为与其为朋友关系的人值</span></span><br><span class="line">                    <span class="comment"># 更新之后，如果是一个朋友圈的，那么在f中的值是相同的</span></span><br><span class="line">                    f[find(x)] = find(y)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(f[x] == x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="回文数"><a href="#回文数" class="headerlink" title=" 回文数"></a><a href="https://leetcode-cn.com/problems/palindrome-number/"> 回文数</a></h2><ul>
<li><p>题意</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 121</span><br><span class="line">输出: true</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br><span class="line">进阶:</span><br><span class="line"></span><br><span class="line">你能不将整数转为字符串来解决这个问题吗？</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/palindrome-number</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
</li>
<li><p>求解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> x%<span class="number">10</span>==<span class="number">0</span> <span class="keyword">or</span> x&lt;<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        strx=<span class="built_in">str</span>(x)</span><br><span class="line">        <span class="keyword">return</span> strx==strx[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>非常简单，直接转换成字符串判断。另外，对特殊情况建议单独处理，避免浪费算力，实际上前面两个if条件如果去掉也能正常运行，但是测试会变慢不少。</p>
</li>
</ul>
<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></h2><ul>
<li><p>题意：</p>
<p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
</li>
<li><p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li>暴力搜索</li>
</ul>
<p>这是一道经典题目，直接暴力搜索肯定可以完成，遍历整个字符串，以当前位置为中心进行前后查找，判断前后位置对应的字符是否相等，直到找到不相同的字符，跳出循环；此外还要判断当前位置的字符和前后位置的字符是否为连续相同的字符，直到遍历完整个字符串，时间复杂度为$O(n^3)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="built_in">len</span>(s)==<span class="number">1</span>: <span class="keyword">return</span> s</span><br><span class="line">        l = <span class="built_in">len</span>(s)</span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        palindromic = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">            x = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 以当前点为中心前后寻找</span></span><br><span class="line">            <span class="keyword">while</span> (i - x) &gt;= <span class="number">0</span> <span class="keyword">and</span> (i + x) &lt; l:</span><br><span class="line">                <span class="keyword">if</span> s[i + x] == s[i - x]:</span><br><span class="line">                    x += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 找到不满足条件的点之后当前已经进行了x+1操作，当前步减去1</span></span><br><span class="line">            x -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 更新长度和返回的回文子串</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">2</span> * x + <span class="number">1</span> &gt; max_length:</span><br><span class="line">                max_length = <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line">                palindromic = s[i - x:i + x + <span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 有可能相邻两位相同，这个时候要进行要进行特殊移动，前移动也行后移动也行的</span></span><br><span class="line">            <span class="comment"># 例如字符串为abbc，如果当前位对应着第一个b，那么前后分别为ba，不满足上面的条件，</span></span><br><span class="line">            <span class="comment"># 上面的方法可以提取奇数个相同的相邻数字</span></span><br><span class="line">            <span class="comment"># 使用下面的条件判定，一直找到不同的数字，对于偶数个相同的相邻数字使用下面的方法提取</span></span><br><span class="line">            x = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &lt; l:</span><br><span class="line">                <span class="keyword">while</span> (i - x) &gt;= <span class="number">0</span> <span class="keyword">and</span> (i + <span class="number">1</span> + x) &lt; l:</span><br><span class="line">                    <span class="comment"># 当前为为i，右侧为i+1+x,左侧为x</span></span><br><span class="line">                    <span class="keyword">if</span> s[i + <span class="number">1</span> + x] == s[i - x]:</span><br><span class="line">                        x += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            x -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># </span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">2</span> * x + <span class="number">2</span> &gt; max_length:</span><br><span class="line">                max_length = <span class="number">2</span> * x + <span class="number">2</span></span><br><span class="line">                palindromic = s[i - x:i + x + <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> palindromic == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            palindromic = s[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> palindromic</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更直白的暴力求解，直接穷举给定字符中所有的长度大于2 的子串，并根据回文子串的定义，进行回文验证。整个复杂度是$,O(n^3)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 暴力匹配（超时）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 特判</span></span><br><span class="line">        size = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        res = s[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 枚举所有长度大于等于 2 的子串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, size):</span><br><span class="line">                <span class="keyword">if</span> j - i + <span class="number">1</span> &gt; max_len <span class="keyword">and</span> self.__valid(s, i, j):</span><br><span class="line">                    max_len = j - i + <span class="number">1</span></span><br><span class="line">                    res = s[i:j + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__valid</span>(<span class="params">self, s, left, right</span>):</span><br><span class="line">        <span class="comment"># 验证子串 s[left, right] 是否为回文串</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>动态规划求解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        size = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> size &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">              </span><br><span class="line">				<span class="comment"># 生成dp图，dp[i][j]表示s[i:j+1]是否为回文子串，如果是就是True,否则就是False</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">				</span><br><span class="line">        <span class="comment"># 对角线为true，实际上对角元素没什么含义，表示s[i]==s[i]，单个字符串肯定是回文的</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            dp[i][i] = <span class="literal">True</span></span><br><span class="line">				<span class="comment"># 这一步很关键，哪一个迭代在先哪一个在先在后</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, j):</span><br><span class="line">				<span class="comment">## 状态转移方程 d[i][j]= (s[i]==s[j]) and dp[i+1][j-1]</span></span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">					<span class="comment"># 边界条件，[i + 1, j - 1]不构成区间，也就是j-1-i-1+1&lt;2，此时dp[i+1][j-1]必然是回文的</span></span><br><span class="line">                    <span class="keyword">if</span> j - i &lt; <span class="number">3</span>:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    cur_len = j - i + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                        max_len = cur_len</span><br><span class="line">                        start = i</span><br><span class="line">        <span class="keyword">return</span> s[start:start + max_len]</span><br></pre></td></tr></table></figure>
</li>
<li><p>中心扩散</p>
<p>和暴力的穷举类似，但是 更加巧妙，一次遍历，遍历到的位置假设为回文子串的中心位置，由中心位置想前后进行扩散，并判断是否是一个回文子串，此外，题目要的最长的回文子串，那么比找到的再短的串就不看了，随着迭代的进行，index每移动一步，观察区间都[i-max_len:i+1]，这不是相对中心位置i为对称的一个区间，这一步不好理解，因为不是从整个序列的中间开始找的，所以，遍历的索引index不太可能是窗口的中心位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">1</span> <span class="keyword">or</span> s == s[::-<span class="number">1</span>]: <span class="keyword">return</span> s</span><br><span class="line">        max_len,start = <span class="number">1</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">          	<span class="comment"># 观察区间的长度可能是偶数或者奇数，两个情况分别处理</span></span><br><span class="line">            <span class="comment"># 向右边扩散位置为1，向左边扩散位置是max_len，</span></span><br><span class="line">            even = s[i-max_len:i+<span class="number">1</span>]</span><br><span class="line">            odd = s[i-max_len-<span class="number">1</span>:i+<span class="number">1</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;env,odd&quot;</span>,even,odd,max_len,i)</span><br><span class="line">            <span class="keyword">if</span> i - max_len - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> odd == odd[::-<span class="number">1</span>]:</span><br><span class="line">                start = i - max_len - <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果是奇数，下次index移动，中心位置是个字符，整个观察区间增大2</span></span><br><span class="line">                max_len += <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i - max_len &gt;= <span class="number">0</span> <span class="keyword">and</span> even == even[::-<span class="number">1</span>]:</span><br><span class="line">                start = i - max_len</span><br><span class="line">                <span class="comment"># 如果是偶数，中心位置是两个字符之间的间隙，因此下次index移动，观察区间只增加1</span></span><br><span class="line">                max_len += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> s[start:start + max_len]</span><br></pre></td></tr></table></figure>


</li>
<li><p>Manacher算法</p>
</li>
</ul>
<p>参考链接 <a href="https://segmentfault.com/a/1190000003914228">https://segmentfault.com/a/1190000003914228</a></p>
</li>
<li><p>代码</p>
</li>
<li><p>Manacher 实现</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        s=<span class="string">&#x27;#&#x27;</span>+<span class="string">&#x27;#&#x27;</span>.join(s)+<span class="string">&#x27;#&#x27;</span></span><br><span class="line"></span><br><span class="line">        RL=[<span class="number">0</span>]*<span class="built_in">len</span>(s)</span><br><span class="line">        MaxRight=<span class="number">0</span></span><br><span class="line">        pos=<span class="number">0</span></span><br><span class="line">        MaxLen=<span class="number">0</span></span><br><span class="line">        out=<span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> i&lt;MaxRight:</span><br><span class="line">                RL[i]=<span class="built_in">min</span>(RL[<span class="number">2</span>*pos-i], MaxRight-i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                RL[i]=<span class="number">1</span></span><br><span class="line">            <span class="comment">#尝试扩n展，注意处理边界</span></span><br><span class="line">            <span class="keyword">while</span> i-RL[i]&gt;=<span class="number">0</span> <span class="keyword">and</span> i+RL[i]&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> s[i-RL[i]]==s[i+RL[i]]:</span><br><span class="line">                RL[i]+=<span class="number">1</span></span><br><span class="line">            <span class="comment">#更新MaxRight,pos</span></span><br><span class="line">            <span class="keyword">if</span> RL[i]+i-<span class="number">1</span>&gt;MaxRight:</span><br><span class="line">                MaxRight=RL[i]+i-<span class="number">1</span></span><br><span class="line">                pos=i</span><br><span class="line">            <span class="comment">#更新最长回文串的长度</span></span><br><span class="line">            <span class="comment"># MaxLen=max(MaxLen,RL[i])</span></span><br><span class="line">            <span class="comment"># return MaxLen-1</span></span><br><span class="line">            <span class="keyword">if</span> RL[i]&gt;MaxLen:</span><br><span class="line">                MaxLen=RL[i]</span><br><span class="line">                out=s[i-RL[i]+<span class="number">1</span>:i+RL[i]]</span><br><span class="line">        <span class="keyword">return</span> out.replace(<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h2><ul>
<li><p>题意</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">      	<span class="comment"># k 子串的结束位置</span></span><br><span class="line">        <span class="comment"># res 子串的长度</span></span><br><span class="line">        <span class="comment"># c_dict 存储字符串的索引和对应的值</span></span><br><span class="line">        k, res, c_dict = -<span class="number">1</span>, <span class="number">0</span>, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="comment"># 字符c在字典中,且上次出现的下标大于当前长度的起始下标，这一步在记录当前的最长无重复子串</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> c_dict <span class="keyword">and</span> c_dict[c] &gt; k: </span><br><span class="line">                k = c_dict[c]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = <span class="built_in">max</span>(res, i-k) <span class="comment"># 字符C不在字典中，更新res, 保持res是遍历到当前的最大的值</span></span><br><span class="line">            c_dict[c] = i</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>在迭代的过程中，记录字符和对应的位置，如果遇到了重复的字符出现，兵器出现重复的这个字符比上一次停止的位置靠后，那么就会更新新的结束标志K。这里面的条件<code>c_dict[c] &gt; k</code>，很重要，如果去掉这个条件，对于<code>tmmzuxt</code>这种类似的数据，当遇到重复字符m的时候，这个时候会更新k的值为1，随着迭代的进行，遇到重复的字符t的时候k又被更新成了0，这个显然是错误的，因为这个时候子串的结束位置显然应该比之前的1更大才对。</p>
</li>
</ul>
<h2 id="m个苹果n个盒子"><a href="#m个苹果n个盒子" class="headerlink" title="m个苹果n个盒子"></a>m个苹果n个盒子</h2><p>这是一个经典的算法题，本题的前提假设是，苹果是相同的，盒子是相同的，并且允许有的盒子空置，问有多少种分法</p>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><ul>
<li><p>如果苹果数量&gt;&#x3D;盒子的数量，以有盒子为空为分界，有两种情况</p>
<ul>
<li>至少一个盒子为空，那么find(m,n-1)</li>
<li>没有盒子为空，那么先在所有的盒子里各放置一个苹果，这个不会影响分配结果，将剩余的苹果分配给这m个盒子，那么find(m-n,n)</li>
</ul>
</li>
<li><p>如果苹果的数量&lt;盒子的数量</p>
<p>肯定至少会有一些盒子是空的，又因为盒子的相同的，那么先去掉一些盒子(n-m)，并不会影响分配方案，也就是将这些苹果分配给剩下的这些盒子，那么对应find(m,m)</p>
</li>
<li><p>边界条件</p>
<ul>
<li>当剩下的盒子数量为1时，不管剩下多少盒子，剩下的这些苹果必须全部放在这个盒子里面，也就是对应着1中分配方案</li>
<li>当剩下的苹果数量为0时，这个时候已经没有苹果了，也是一种分配方案</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">m,n</span>):</span><br><span class="line">	<span class="keyword">if</span> m==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> m&lt;n:</span><br><span class="line">		<span class="keyword">return</span> find(m,m)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> find(m-n,n)+find(m,n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="m个苹果n个人"><a href="#m个苹果n个人" class="headerlink" title="m个苹果n个人"></a>m个苹果n个人</h2><p>本题是上一个题目”m个苹果n个盒子”的升级版。</p>
<p>苹果相同，人是不同的，并且允许有的人拿不到苹果，问多少种分法</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>假设存在m个苹果，n个人来分，先给一个人拿一个苹果，那么剩下的m-1个苹果，由剩下的人来分，剩下了可能是n个人，也可能是n-1个人；直到剩下的苹果全部分完，在递归过程中，每次当前的人分的一个苹果，在查看剩下的m-1个苹果别的分配情况，苹果分完之后，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nums</span>(<span class="params">m,n</span>):</span><br><span class="line">    </span><br><span class="line">    result=[]</span><br><span class="line">    out=[<span class="number">0</span>]*n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">m,n,p</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;out:&#x27;</span>,out)</span><br><span class="line"><span class="comment">#             result.append(out)</span></span><br><span class="line"><span class="comment">#             print(result)</span></span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(p,n):</span><br><span class="line">            out[i]=out[i]+<span class="number">1</span></span><br><span class="line">            find(m-<span class="number">1</span>,n,i)</span><br><span class="line">            out[i]=out[i]-<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    find(m,n,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">res=nums(<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="宝石与石头-E"><a href="#宝石与石头-E" class="headerlink" title="宝石与石头[E]"></a>宝石与石头[E]</h2><ul>
<li><p>原题链接：<a href="https://leetcode-cn.com/problems/jewels-and-stones/">https://leetcode-cn.com/problems/jewels-and-stones/</a></p>
</li>
<li><p>题意：</p>
<p>给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p>
<p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p>
</li>
<li><p>示例 1:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>示例 2:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J = &quot;z&quot;, S = &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意:</p>
<p>S 和 J 最多含有50个字母。<br> J 中的字符不重复。</p>
</li>
<li><p>解析</p>
</li>
</ul>
<p>  这道题很简单，两个序列，求一个序列中某些字符出现的次数</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numJewelsInStones</span>(<span class="params">self, J: <span class="built_in">str</span>, S: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        num=<span class="number">0</span></span><br><span class="line">        <span class="comment">## method1</span></span><br><span class="line">        <span class="comment"># for i in J:</span></span><br><span class="line">        <span class="comment">#     num+=S.count(i)</span></span><br><span class="line">        <span class="comment"># return num</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">## method2</span></span><br><span class="line">        <span class="comment"># for i in S:</span></span><br><span class="line">        <span class="comment">#     if i in J:</span></span><br><span class="line">        <span class="comment">#         num+=1</span></span><br><span class="line">        <span class="comment"># return num</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">## method3</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(S.count(i) <span class="keyword">for</span> i <span class="keyword">in</span> J)</span><br></pre></td></tr></table></figure>

<p>  三种方法基本一致，方法2算是原生实现，没有调用count的方法，此外，由于给了条件J的字符不重复，因此这里没有进行<code>J=set(J)</code>的处理。</p>
<h2 id="Z字形变换"><a href="#Z字形变换" class="headerlink" title="Z字形变换"></a>Z字形变换</h2><ul>
<li><p>原题链接：<a href="https://leetcode-cn.com/problems/zigzag-conversion/">https://leetcode-cn.com/problems/zigzag-conversion/</a></p>
</li>
<li><p>题意：</p>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure>


<p>​	之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p>
<p>​	请你实现这个将字符串进行指定行数变换的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>


<p>​	示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3</span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br></pre></td></tr></table></figure>

<p>​	示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解析</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">self, s: <span class="built_in">str</span>, numRows: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> numRows &lt; <span class="number">2</span>: <span class="keyword">return</span> s</span><br><span class="line">        res = [<span class="string">&quot;&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numRows)]</span><br><span class="line">        i, flag = <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            res[i] += c</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i == numRows - <span class="number">1</span>: flag = -flag</span><br><span class="line">            i += flag</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br></pre></td></tr></table></figure>

<p>设置一个指针flage，按照给定的题意，生成n行，对每行的数据，按照z字形生成，数据会先向下在向上进行，转折点是行的索引为上下的两个点，也就是索引为0或者索引为n-1的时候。</p>
<img src="/2018/11/06/LeetCode/z-trans.png" class=""></li>
</ul>
<h2 id="手写经典算法"><a href="#手写经典算法" class="headerlink" title="手写经典算法"></a>手写经典算法</h2><h3 id="积分图-avgpooling-maxpooling"><a href="#积分图-avgpooling-maxpooling" class="headerlink" title="积分图&#x2F;avgpooling&#x2F;maxpooling"></a>积分图&#x2F;avgpooling&#x2F;maxpooling</h3><p>在计算机视觉领域中，如果要对一幅图像使用不同的方框滤波器重复卷积的时候，可以先计算区域求和表。区域求和表是指一定区域内所有像素的值的和，计算方法如下。<br>$$<br>s(i, j)&#x3D;\sum_{k&#x3D;0}^{i} \sum_{l&#x3D;0}^{j} f(k, l)<br>$$<br>$f(k,l)$表示图像中点$(i,j)$对应的值。在实际计算的时候一般是利用递归的方法去计算<br>$$<br>s(i, j)&#x3D;s(i-1, j)+s(i, j-1)-s(i-1, j-1)+f(i, j)<br>$$<br>在这里$s(i,j)$通常被称作积分图，也就是点$(i,j)$到左上角区域的所有元素的和。</p>
<ul>
<li><p>积分图计算代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def</span><br></pre></td></tr></table></figure>


</li>
<li><p>手写公式</p>
<p>给定图像，尺寸为w,h,c，使用尺寸为k的方形滤波器以步长为s进行滤波，计算滤波之后的图像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div>赏杯咖啡！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat.jpeg" alt="ShiXiaofeng 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpeg" alt="ShiXiaofeng 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>ShiXiaofeng
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://xiaofengshi.com/2018/11/06/LeetCode/" title="LeetCode算法训练">http://xiaofengshi.com/2018/11/06/LeetCode/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/11/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%81%9A%E7%B1%BB/" rel="prev" title="机器学习-聚类">
      <i class="fa fa-chevron-left"></i> 机器学习-聚类
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/11/04/blog-make/" rel="next" title="使用Hexo搭建基于Github的私人博客">
      使用Hexo搭建基于Github的私人博客 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-number">1.</span> <span class="nav-text">买卖股票的最佳时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="nav-number">2.</span> <span class="nav-text">买卖股票最佳时机 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="nav-number">3.</span> <span class="nav-text">最佳买卖股票时机含冷冻期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nim%E6%B8%B8%E6%88%8F"><span class="nav-number">4.</span> <span class="nav-text">Nim游戏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-number">5.</span> <span class="nav-text">旋转数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">6.</span> <span class="nav-text">整数反转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">7.</span> <span class="nav-text">正则表达式匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi"><span class="nav-number">8.</span> <span class="nav-text">字符串转换整数 (atoi)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D"><span class="nav-number">9.</span> <span class="nav-text">存在重复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">10.</span> <span class="nav-text">只出现一次的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-II"><span class="nav-number">11.</span> <span class="nav-text">两个数组的交集 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E4%B8%80"><span class="nav-number">12.</span> <span class="nav-text">加一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="nav-number">13.</span> <span class="nav-text">移动零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">14.</span> <span class="nav-text">两数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">15.</span> <span class="nav-text"> 三数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-number">16.</span> <span class="nav-text">两数相加</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="nav-number">17.</span> <span class="nav-text">最小栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E7%9A%84%E5%B9%82"><span class="nav-number">18.</span> <span class="nav-text">3的幂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6"><span class="nav-number">19.</span> <span class="nav-text">二叉树的坡度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">20.</span> <span class="nav-text">寻找两个有序数组的中位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80"><span class="nav-number">21.</span> <span class="nav-text">复原ip地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="nav-number">22.</span> <span class="nav-text">反转字符串的单词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">23.</span> <span class="nav-text">搜索旋转排序数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97"><span class="nav-number">24.</span> <span class="nav-text">第k个排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8B%E5%8F%8B%E5%9C%88"><span class="nav-number">25.</span> <span class="nav-text">朋友圈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E6%95%B0"><span class="nav-number">26.</span> <span class="nav-text"> 回文数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">27.</span> <span class="nav-text">最长回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-number">28.</span> <span class="nav-text">无重复字符的最长子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#m%E4%B8%AA%E8%8B%B9%E6%9E%9Cn%E4%B8%AA%E7%9B%92%E5%AD%90"><span class="nav-number">29.</span> <span class="nav-text">m个苹果n个盒子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95"><span class="nav-number">29.1.</span> <span class="nav-text">迭代方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#m%E4%B8%AA%E8%8B%B9%E6%9E%9Cn%E4%B8%AA%E4%BA%BA"><span class="nav-number">30.</span> <span class="nav-text">m个苹果n个人</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">30.1.</span> <span class="nav-text">分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4-E"><span class="nav-number">31.</span> <span class="nav-text">宝石与石头[E]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="nav-number">32.</span> <span class="nav-text">Z字形变换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95"><span class="nav-number">33.</span> <span class="nav-text">手写经典算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%AF%E5%88%86%E5%9B%BE-avgpooling-maxpooling"><span class="nav-number">33.1.</span> <span class="nav-text">积分图&#x2F;avgpooling&#x2F;maxpooling</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ShiXiaofeng"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ShiXiaofeng</p>
  <div class="site-description" itemprop="description">LLM,搜索,数据挖掘,深度学习相关技术记录分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xiaofengShi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaofengShi" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:sxf1052566766@163.com" title="E-Mail → mailto:sxf1052566766@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShiXiaofeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v7.1.1
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>









<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '500px'
      });
    });
  }, window.PDFObject);
}
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'rBlWbsM2JDda6CTwJlGaUFpI-gzGzoHsz',
      appKey: 'zJasiQnAqgUwf4kiHhHyXwOP',
      placeholder: "Leave Your Message and Contact Details",
      avatar: 'mm',
      meta: guest,
      pageSize: '10' || 10,
      visitor: true,
      lang: '' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
